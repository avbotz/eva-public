eva: {
	min_depth = 30;	#the minimum depth to maintain
	is_competition_side = true;
	# This sets whether to grab images from the cameras
	# or from an image file generated by a simulator
	simulation = true;
};

gate: {
	vision_time = -1;
	initial_pause_time = -1;
	time = 6000;	#the time(ms) to advance under the gate
	#NOTE: If you make the gate time too small, and the cameras won't have enough
	#time to drop the initial frames and the program will crash
	power = 200;	#the forward power to advance under the gate
	depth = 40;		#the initial depth of the submarine
	
	min_total_intensity = 150000;
	min_pixel_intensity = 100;
	
	next_task = ["buoy"];	#the tasks to be started afterwards
};

buoy: {
	# thresholding options; look in buoy.cpp for more details
	rb = 100;
	rg = 135;
	gr = 60;
	gb = 65;
	r_min_pixel_intensity = 145;
	w_min_pixel_intensity = 150;
	
	blob_min_area = 200;
	blob_max_area = 50000;
	
	depth = 100;
	max_depth = 140;

	backup_time = 10000;
	move_on_time = 10000;
	ram_area = 16000;
	ram_accuracy = 0.08;
	ram_time = 7000;

	move_on_depth = 60;
	heading_constant = 60; # factor that's multiplied by horizontal distance
	depth_constant = 30; # factor that's multiplied by vertical distance

	h_threshold = 0.1; # allowed offset from center
	v_threshold = 0.1; # measured in frac of height or width

	end_angle_offset = 0;

	wall_blob_height = 0.5;
	wall_blob_distance_x = 0.45;
	min_buoy_circularity = 0.7;
	min_buoy_density = 0.75;
	glare_blob_width = 0.6;
	glare_blob_height = 0.45;

	blob_prop_ratio = 5.0;
	blob_prop_width = 0.2;
	blob_prop_height = 0.2;
	
	next_task = ["path"];
};


path: {
	min_total_intensity = 500000;
	
	timeout = 10000;
	
	follow_time = 5000;
	
	gate: { # if we came from gate, we skipped buoy
		num_paths = 1;
		preferred_path = 0;	# if multiple paths, 0 points to middle of pool, 1 to perimeter
		next_task = ["l_gate"];
		proceed_time = 5000;
	};
	
	buoy: {
		num_paths = 1;
		preferred_path = 0;
		next_task = ["l_gate"];
		proceed_time = 15000;
	};
	
	l_gate: {
		num_paths = 1;
		preferred_path = 0;
		next_task = ["dropper"];
		proceed_time = 10000;
	};

	dropper: {
		num_paths = 1;
		preferred_path = 0;
		next_task = ["hydrophone"];
		proceed_time = 0;
	};

	path: {
		num_paths = 1;
		preferred_path = 0;
		next_task = ["hydrophone"];
		proceed_time = 0;
	};
};

l_gate: {
	depth = 100;
	init_power = 200;
	approach_power = 200;
	approach_wait_time = 8000;
	adjust_wait_time = 5000;
	adjust_timeout = 5000;

	turn_heading = 10;
	
	rb_pixel_intensity = 60;
	rg_pixel_intensity = 50;
	r_min_blob_area = 100;
	gr_pixel_intensity = 10;
	gb_pixel_intensity = 10;
	g_min_blob_area = 100;
	w_min_pixel_intensity = 225;

	# check for green pvc on down camera
	# set to false to use a timeout instead
	check_green = true;

	attempt_circle = true;
	circle_power1 = 150;
	circle_power2 = 180;
	circle_increment = -45;
	circle_turn_time = 3000;
	circle_move_time = 1500;

	end_power = 150;
	end_pause = 4000;
	end_angle_offset = 0;

	box_ratio = 0.3;

	next_task = ["path"];
};

search: {
	timeout = 80000;
	power = 160;
};

dropper: {
	primary_depth = 100;
	
	min_bin_area = 50;
	max_bin_area = 40000;
	min_border_area = 50;
	max_border_area = 4000000;
	min_bin_border_dist = 0;
	max_bin_border_dist = 5000000;
	density = 0.6;

	min_thres_border = 100;
	max_thres_bin = 20;

	go_to_bin_power = 200;
	go_to_bin_time = 3000;
	go_to_bin_angle = -45;
	
	adjust_heading_time = 8000;

	aligned = 10;

	dist_all_bins = 0.25; # distance to centroid of all bins
	dist_bin = 0.04;      # distance to desired bin
                          # measured by frac of image diagonal

	img0 = "0.png";
	img1 = "1.png";
	img2 = "2.png";
	img3 = "3.png";
	is_valid0 = true;
	is_valid1 = true;
	is_valid2 = false;
	is_valid3 = false;
	bin_position0 = 0;
	bin_position1 = 1;
	bin_position2 = 2;
	bin_position3 = 3;
	use_image_detection = true;
	
	canthres = 250; 	#low threshold for canny edge detection
	canratio = 3; 		#multiplier for low to high threshold
	linethres = 50; 	#minimum points for a line

	accuracy_threshold = 0;

	camera_offset = 0; #how much higher the camera is than the dropper,
                       #fraction of image height

	end_angle_offset = -45;
	end_pause_time = 25000;

	search_power = 150;
	approach_power = 80;            # multiplied by distance to target and added to 100
	slow_approach_multiplier = 0.2; # multiplied to approach_power when approaching slowly

	next_task = ["path"];
};

hydrophone: {
}

vision: {
	#no_tracking = 0;				#If vision is allowed to go into track mode and seize control of the submarine
	snapshot_enable = true;			#Save frames periodically
	snapshot_time = 10;				#The number of frames between saved frames
	#frame_trim_bottom = 0;			#The number of rows at the bottom of the frame to ignore (engine bars)
	
	#fps_basic = 1;					#FPS when not running a specific task
	#fps_intense = 12;				#FPS when running a specific task
    height = 720;                   #resolution
    width = 1280;
	master_downsample_ratio = 2;
	fov_horizontal = 60;			#horizontal field of view in degrees
	fov_vertical = 34;				#vertical field of view in degrees
	
	camera_id_front = "/dev/video0";
	camera_id_down = "/dev/video1";
};

visiontask: {
	stop_time_scale = 100;
};


serial: {
	mbed_port = "./mbed"; #mbed comm port
	status_print_interval = 10;
};

visionsim: {
	camera_filename = "Camera.png";
};
